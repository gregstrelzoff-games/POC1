<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dominion POC — Player vs AI (v8.5.8)</title>
  <style>
    :root{
      --bg:#0f1220; --canvas:#12162b; --panel:#141a30; --panel2:#0f152b; --muted:#20264a; --text:#eef2ff; --sub:#c5cbff;
      --accent:#7c9cff; --accent2:#2bbf85; --danger:#ff5e6b; --shadow:0 10px 30px rgba(0,0,0,.45); --radius:14px; --mint:#a1ffd8;
      --chat:#0b1022; --tipbg:#13205a; --tipborder:#28366f; --outline:#2a335a;
    }
    *{box-sizing:border-box}
    body{margin:0;background:radial-gradient(1200px 800px at 70% -10%, #1a2040, var(--canvas));color:var(--text);font:14px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    h1{font-size:22px;margin:12px 0 6px}
    .app{max-width:1200px;margin:18px auto;padding:12px}

    /* Clean darker header (build removed) */
    .topbar{display:flex;align-items:center;gap:16px;justify-content:space-between;background:linear-gradient(180deg,#1b223e,#151a33);border:1px solid #2a335a;border-radius:var(--radius);padding:12px 16px;box-shadow:var(--shadow)}
    .top-left h1{margin:0;color:#eaf0ff}
    .topbar-right{display:flex;gap:14px;align-items:center}
    .control-line{margin-top:6px;color:#eaf0ff}
    .toggle{display:inline-flex;gap:8px;align-items:center;color:#eaf0ff}
    .toggle input, .toggle select{accent-color:var(--accent);background:#0e1326;border:1px solid #293056;color:#fff;border-radius:8px;padding:4px 8px}

    .row{display:grid;grid-template-columns:1.2fr .8fr;gap:16px;margin-top:16px}
    .panel{background:linear-gradient(180deg,#171b2e,#12182b);border:1px solid #232848;border-radius:var(--radius);box-shadow:var(--shadow);color:#eef1ff}
    .panel h2{font-size:16px;margin:0;padding:10px 12px;border-bottom:1px solid #232848;color:#b9c0ff}

    /* soft vignette under Play Area */
    .playArea{position:relative;overflow:hidden}
    .playArea::after{content:"";position:absolute;inset:-20%;background:radial-gradient(600px 200px at 50% 10%, rgba(0,0,0,.28), rgba(0,0,0,0) 70%);pointer-events:none}

    /* Status */
    .stats{display:flex;gap:12px;align-items:center;color:#c6cdfc;flex-wrap:wrap}
    .pill{display:inline-flex;gap:6px;align-items:center;background:#1b2347;border:1px solid #2a2f4c;border-radius:999px;padding:6px 10px}
    .pill strong{color:#fff}
    .stats-rows{padding:12px}
    .stats-rows .stats{margin:4px 0}
    .score{font-weight:800;color:var(--accent2);font-size:16px}

    /* Supply */
    .supplySections{padding:12px}
    .supplySection{padding:12px 0;border-top:1px solid #232848}
    .supplySection:first-child{border-top:0}
    .supplySection h3{margin:0 0 8px;color:#b9c0ff;font-size:13px;letter-spacing:.05em;text-transform:uppercase}
    .supplyGrid{display:grid;grid-template-columns:repeat(5,minmax(0,1fr));gap:10px}

    .pile{background:linear-gradient(180deg,#1a2040,#141a34);border:1px solid #2b3158;border-radius:12px;padding:10px;cursor:pointer;transition:transform .08s ease, box-shadow .08s ease;position:relative}
    .pile:hover{transform:translateY(-1px);box-shadow:0 8px 20px rgba(0,0,0,.35)}
    .pile .name{font-weight:700}
    .pile .meta{font-size:12px;color:#b9c0ff}
    .pile .count{position:absolute;right:8px;top:8px;background:#10162a;border:1px solid #2a2f4c;border-radius:999px;padding:2px 8px;font-size:12px;color:#cbd3ff}
    .pile.disabled{opacity:.55;cursor:not-allowed}
    .pile.empty{background:repeating-linear-gradient(135deg,#2a0f18,#2a0f18 10px,#1a0b12 10px,#1a0b12 20px);border-color:var(--danger);box-shadow:0 0 0 1px var(--danger) inset;opacity:0.95}
    .pile.empty .count{background:#2a0f18;border-color:var(--danger);color:#ffc9c9}
    .pile.empty::after{content:'EMPTY';position:absolute;left:-6px;top:8px;transform:rotate(-12deg);background:rgba(255,107,107,.12);border:1px dashed var(--danger);color:#ffc9c9;font-weight:700;padding:2px 6px;border-radius:6px;font-size:11px}

    /* Buyable highlight */
    @keyframes pulseGlow{0%{box-shadow:0 0 0 0 rgba(124,156,255,.35)}70%{box-shadow:0 0 0 10px rgba(124,156,255,0)}100%{box-shadow:0 0 0 0 rgba(124,156,255,0)}}
    .pile.buyable{outline:2px solid #7c9cff; animation:pulseGlow 1.6s ease-out infinite}

    /* Hand */
    .hand{display:flex;flex-wrap:wrap;gap:10px;padding:12px}
    .card{min-width:128px;background:linear-gradient(180deg,#20264a,#151b3a);border:1px solid #2b3158;border-radius:12px;padding:10px;box-shadow:var(--shadow);cursor:default;position:relative}
    .card .title{font-weight:700;margin-bottom:6px}
    .card .type{font-size:12px;color:#b9c0ff}
    .card.playable{outline:2px solid #7c9cff;cursor:pointer}
    .card.disabled{opacity:.55;cursor:not-allowed;outline:none}

    .actions{display:flex;gap:10px;align-items:center;padding:0 12px 12px;flex-wrap:wrap}
    .btn{background:linear-gradient(180deg,#2a3160,#20264a);border:1px solid #36407a;border-radius:10px;padding:8px 12px;color:#fff;cursor:pointer;transition:transform .06s ease}
    .btn:active{transform:translateY(1px)}

    .log{min-height:28px;padding:10px 12px;color:#cbd3ff;white-space:pre-wrap}
    .log .mint{color:var(--mint)}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:12px; white-space:pre-wrap}
    .toast{position:fixed;bottom:18px;right:18px;background:#0e1326;border:1px solid #293056;color:#fff;padding:10px 14px;border-radius:12px;box-shadow:var(--shadow);opacity:0;transform:translateY(12px);transition:opacity .18s ease, transform .18s ease}
    .toast.show{opacity:1;transform:translateY(0)}

    .build{position:fixed;right:10px;bottom:8px;font-size:12px;color:#9aa3ff;pointer-events:none;font-weight:800;text-shadow:0 0 12px rgba(124,156,255,.45)}

    /* Game Status row + Your Cards */
    .countsList{font-size:14px;line-height:1.35;color:#cbd3ff;padding:12px}
    .countGroup{margin-bottom:8px}
    .countGroup:last-child{margin-bottom:0}
    .countsList .row{display:flex;justify-content:space-between;margin:0;line-height:1.2}
    .countsList .label{color:#cbd3ff}
    .countsList .sub{font-size:12px;color:#8e96d9;margin:0 0 2px}
    .countsList .row + .sub{margin-top:-2px}
    .countsList .totalWrap{display:flex;flex-direction:column;align-items:flex-end}
    .countsList .mini{font-size:10px;text-transform:uppercase;letter-spacing:.06em;color:#8e96d9}
    .countsList .totalNum{font-size:16px;color:#eef1ff}

    /* Modal */
    .overlay{position:fixed;inset:0;background:rgba(4,6,18,.7);display:none;align-items:center;justify-content:center;z-index:9000}
    .overlay.show{display:flex}
    .modal{background:#0e1326;border:1px solid #293056;border-radius:16px;box-shadow:var(--shadow);padding:18px 18px 14px;max-width:560px;min-width:320px;display:flex;flex-direction:column;align-items:center;text-align:center;color:#f0f3ff}
    .modal h3{margin:0 0 6px;font-size:22px;color:#fff}
    .modal p{margin:6px 0 14px;color:#e0e6ff}
    .modal .footer{margin-top:10px;width:100%;display:flex;justify-content:center}

    /* Tooltip (blue background, no native titles) */
    .tooltip{position:fixed;z-index:10050;display:none;max-width:260px;background:var(--tipbg);border:1px solid var(--tipborder);border-radius:10px;box-shadow:var(--shadow);padding:8px 10px;color:#eef1ff}
    .tooltip .tTitle{font-weight:700;margin-bottom:4px}
    .tooltip .tMeta{font-size:12px;color:#a8b0ff}

    /* Chat bot (always open; brighter text) */
    .chat-panel{position:fixed;right:18px;bottom:88px;width:320px;max-height:60vh;display:flex;flex-direction:column;background:#0f1633;border:1px solid var(--outline);border-radius:14px;box-shadow:var(--shadow);overflow:hidden;z-index:10020;color:#f6f8ff}
    .chat-head{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;background:#0f1530;border-bottom:1px solid #262f57;color:#f6f8ff}
    .chat-head .title{font-weight:700;color:#f6f8ff}
    .chat-head .tools{display:flex;gap:6px}
    .chat-body{padding:10px;overflow:auto;display:flex;flex-direction:column;gap:8px}
    .msg{display:flex;gap:8px;align-items:flex-start}
    .msg .bubble{padding:8px 10px;border-radius:10px;max-width:240px;color:#ffffff}
    .msg.bot .bubble{background:#16204a;border:1px solid #29356e}
    .msg.user{justify-content:flex-end}
    .msg.user .bubble{background:#1e274f;border:1px solid #33407c}
    .chat-input{display:flex;gap:6px;padding:10px;border-top:1px solid #262f57}
    .chat-input input{flex:1;background:#0e1326;color:#fff;border:1px solid #293056;border-radius:10px;padding:8px}
    .chat-input button{background:#1e274f;color:#fff;border:1px solid #33407c;border-radius:10px;padding:8px 10px;cursor:pointer}
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="top-left">
        <h1>Dominion — POC (You vs AI)</h1>
        <div class="control-line"><label class="pill toggle"><input type="checkbox" id="autoAdvance"> Auto-advance phases</label></div>
        <div class="control-line">
          <label class="pill toggle">AI:
            <select id="aiMode">
              <option value="weak">Weak</option>
              <option value="strong" selected>Strong</option>
            </select>
          </label>
        </div>
        <div class="control-line"><label class="pill toggle"><input type="checkbox" id="debugAICheck"> Debug AI</label></div>
      </div>
      <div class="topbar-right">
        <button class="btn" onclick="location.reload()">New Game</button>
      </div>
    </div>

    <div class="row">
      <div class="panel">
        <h2>Supply</h2>
        <div id="supply" class="supplySections"></div>
      </div>
      <div class="panel">
        <h2>AI Status & Log</h2>
        <div class="log" id="ai-status">Waiting for your turn…</div>
        <div class="log mono" id="ai-debug" style="display:none"></div>
        <div class="log mono" id="log">Action > Treasure > Buy. Once you buy, you can't play more cards this turn.</div>
      </div>
    </div>

    <div class="row" style="margin-top:16px">
      <div class="panel">
        <h2>Game Status</h2>
        <div class="stats-rows">
          <div class="stats">
            <span class="pill score">Score: <span style="opacity:.9">You</span> <strong id="pScore">0</strong> · AI <strong id="aScore">0</strong></span>
          </div>
          <div class="stats">
            <span class="pill">Phase: <strong id="phase">Action</strong></span>
          </div>
          <div class="stats">
            <span class="pill">Actions: <strong id="actions">1</strong></span>
            <span class="pill">Buys: <strong id="buys">1</strong></span>
            <span class="pill">Coins: <strong id="coins">0</strong></span>
          </div>
        </div>
      </div>
      <div class="panel">
        <h2>Your Cards</h2>
        <div id="playerCounts" class="countsList"></div>
      </div>
    </div>

    <div class="panel playArea" style="margin-top:16px">
      <h2>Your Hand</h2>
      <div id="player-hand" class="hand"></div>
      <div class="actions">
        <button class="btn" id="toBuyBtn" title="B">Go to Buy Phase</button>
        <button class="btn" id="autoTreasureBtn" title="T">Auto-Play Treasures</button>
        <button class="btn" id="undoBtn" title="Z">Undo last</button>
        <button class="btn" id="endTurnBtn" title="E">End Turn</button>
      </div>
      <div class="log mono" style="opacity:.8;padding-top:0">Shortcuts: A=play Action, T=auto-Treasure, B=Buy, E=End Turn, Z=Undo</div>
    </div>
  </div>

  <!-- Chat ALWAYS open, raised above build tag -->
  <div class="chat-panel" id="chatPanel">
    <div class="chat-head"><span class="title">Table Talk</span><div class="tools"><button class="btn" id="clearChat" title="Clear chat">🧹</button></div></div>
    <div class="chat-body" id="chatBody"></div>
    <div class="chat-input"><input id="chatInput" placeholder="Say something…"/><button id="chatSend">Send</button></div>
  </div>

  <div class="toast" id="toast"></div>
  <div class="build" id="build"></div>

  <div class="overlay" id="overlay">
    <div class="modal" id="modal">
      <h3 id="winnerTitle">Game Over</h3>
      <p id="winnerDetail"></p>
      <div class="footer"><button class="btn" onclick="location.reload()">New Game</button></div>
    </div>
  </div>

  <!-- Choice overlay (e.g., Workshop) -->
  <div class="overlay" id="choiceOverlay">
    <div class="modal" id="choiceModal">
      <h3 id="choiceTitle">Gain a card</h3>
      <p id="choiceDetail">Pick a card.</p>
      <div id="choiceGrid" class="supplyGrid"></div>
    </div>
  </div>

  <!-- First-time guide overlay (unchanged) -->
  <div class="coach" id="coach">
    <div class="step" id="coachStep" style="left:40px;top:40px">
      <div class="title" id="coachTitle">Welcome!</div>
      <div id="coachText">Let’s do a quick tour.</div>
      <div class="controls">
        <button class="btn2" id="coachSkip">Skip</button>
        <button class="btn2" id="coachNext">Next →</button>
      </div>
    </div>
  </div>

  <div class="tooltip" id="tooltip"></div>

<script>
// ------------------- Build Tag -------------------
const BUILD = { num: 'v8.5.8', date: new Date().toLocaleDateString(undefined,{year:'numeric',month:'short',day:'2-digit'}) };
(function(){ document.getElementById('build').textContent = `Build ${BUILD.num} • ${BUILD.date}`; })();

// ------------------- Card Definitions -------------------
const CARD_DEFS = {
  Copper:    { name:'Copper',    cost:0, type:'Treasure', value:1, desc:'+1 coin' },
  Silver:    { name:'Silver',    cost:3, type:'Treasure', value:2, desc:'+2 coins' },
  Gold:      { name:'Gold',      cost:6, type:'Treasure', value:3, desc:'+3 coins' },
  Estate:    { name:'Estate',    cost:2, type:'Victory',  points:1, desc:'Worth 1 VP at end of game' },
  Duchy:     { name:'Duchy',     cost:5, type:'Victory',  points:3, desc:'Worth 3 VP at end of game' },
  Province:  { name:'Province',  cost:8, type:'Victory',  points:6, desc:'Worth 6 VP at end of game' },
  Smithy:    { name:'Smithy',    cost:4, type:'Action',   desc:'+3 cards',
               effect: (g,actor)=>{ drawCards(actor,3); if(actor===g.player) addLog(`You played Smithy and drew 3 cards.`); } },
  Village:   { name:'Village',   cost:3, type:'Action',   desc:'+1 card, +2 actions',
               effect: (g,actor)=>{ drawCards(actor,1); if(actor===g.player){ g.actions += 2; addLog(`You played Village: +1 card, +2 actions.`);} else { g.aiActions += 2; } } },
  Market:    { name:'Market',    cost:5, type:'Action',   desc:'+1 card, +1 action, +1 buy, +1 coin',
               effect: (g,actor)=>{ drawCards(actor,1); if(actor===g.player){ g.actions += 1; g.buys += 1; g.coins += 1; addLog('You played Market: +1 card, +1 action, +1 buy, +1 coin.'); } else { g.aiActions += 1; g.aiBuys += 1; g.aiCoins += 1; } } },
  Laboratory:{ name:'Laboratory',cost:5, type:'Action',   desc:'+2 cards, +1 action',
               effect: (g,actor)=>{ drawCards(actor,2); if(actor===g.player){ g.actions += 1; addLog('You played Laboratory: +2 cards, +1 action.'); } else { g.aiActions += 1; } } },
  Festival:  { name:'Festival',  cost:5, type:'Action',   desc:'+2 actions, +1 buy, +2 coins',
               effect: (g,actor)=>{ if(actor===g.player){ g.actions += 2; g.buys += 1; g.coins += 2; addLog('You played Festival: +2 actions, +1 buy, +2 coins.'); } else { g.aiActions += 2; g.aiBuys += 1; g.aiCoins += 2; } } },
  Woodcutter:{ name:'Woodcutter',cost:3, type:'Action',   desc:'+1 buy, +2 coins',
               effect: (g,actor)=>{ if(actor===g.player){ g.buys += 1; g.coins += 2; addLog('You played Woodcutter: +1 buy, +2 coins.'); } else { g.aiBuys += 1; g.aiCoins += 2; } } },
  Merchant:  { name:'Merchant',  cost:3, type:'Action',   desc:'+1 card, +1 action. Next time you play a Silver this turn: +1 coin (stacks)',
               effect: (g,actor)=>{ drawCards(actor,1); if(actor===g.player){ g.actions += 1; g.merchantPending.player++; addLog('You played Merchant: +1 card, +1 action. Silver gets +1 when first played.'); } else { g.aiActions += 1; g.merchantPending.ai++; } } },
  Workshop:  { name:'Workshop',  cost:3, type:'Action',   desc:'Gain a card costing up to 4 to your discard',
               effect: (g,actor)=>{
                 if(actor===g.player){ openGainChoice(4, g.player, 'Workshop'); }
                 else {
                   const pick = aiGainChoiceUpTo(4);
                   if(pick){ const pile=getPile(pick); if(pile&&pile.count>0){ pile.count--; g.ai.discard.push(instance(pick)); } }
                 }
               } },
};

// Supply piles
const SUPPLY = [
  { key:'Copper',   count:60 },
  { key:'Silver',   count:40 },
  { key:'Gold',     count:30 },
  { key:'Estate',   count:24 },
  { key:'Duchy',    count:12 },
  { key:'Province', count:12 },
  { key:'Smithy',   count:10 },
  { key:'Village',  count:10 },
  { key:'Market',   count:10 },
  { key:'Laboratory',count:10 },
  { key:'Festival', count:10 },
  { key:'Woodcutter',count:10 },
  { key:'Merchant', count:10 },
  { key:'Workshop', count:10 },
];

// ------------------- Game State -------------------
const game = {
  player:{ deck:[], discard:[], hand:[], played:[] },
  ai:     { deck:[], discard:[], hand:[], played:[] },
  actions:1, buys:1, coins:0, turn:'player', phase:'action',
  autoAdvance:true,
  debugAI:false,
  aiActions:1, aiBuys:1, aiCoins:0,
  endAfterThisTurn:false, gameOver:false,
  aiMode:'strong',
  undo:null,
  undoForbidden:null, // 'draw' when a draw occurred after snapshot
  suppressAutoAdvanceOnce:false,
  interactionLock:false,
  merchantPending:{ player:0, ai:0 },
  turnNum:1,
};

// ------------------- Tiny log history -------------------
const LOG_MAX = 10; let LOG_SILENT=false;
const logs = [];
function addLog(msg, cls){
  if(LOG_SILENT) return;
  logs.push({msg, cls});
  while(logs.length>LOG_MAX) logs.shift();
  const el = document.getElementById('log');
  if(el) el.innerHTML = logs.map(l=>`<span class="${l.cls||''}">• ${l.msg}</span>`).join('\n');
}
function toast(msg){ const t=document.getElementById('toast'); t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'), 1800); }

// ------------------- Tooltip helpers -------------------
const tip = document.getElementById('tooltip');
function showTip(html, x, y){
  tip.innerHTML = html; tip.style.display='block';
  const pad=10; const w=260; const h= tip.offsetHeight||100;
  let left = Math.min(window.innerWidth - w - pad, x + 14);
  let top  = Math.min(window.innerHeight - h - pad, y + 14);
  tip.style.left = left + 'px'; tip.style.top = top + 'px';
}
function hideTip(){ tip.style.display='none'; }
function cardTip(def){
  const meta = [];
  if(def.type==='Treasure') meta.push(`+${def.value} coins`);
  if(def.type==='Victory') meta.push(`${def.points} VP`);
  if(def.type==='Action') meta.push(def.desc||'Action');
  return `<div class="tTitle">${def.name}</div><div class="tMeta">Type: ${def.type} · Cost: ${def.cost}</div><div style="margin-top:4px">${meta.join(' · ')}</div>`;
}

// ------------------- Helpers -------------------
function instance(name){ return { ...CARD_DEFS[name] }; }
function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }
function packActor(actor){
  return {
    deck: actor.deck.map(c=>c.name),
    discard: actor.discard.map(c=>c.name),
    hand: actor.hand.map(c=>c.name),
    played: actor.played.map(c=>c.name),
  };
}
function unpackActor(p){
  return {
    deck: p.deck.map(instance),
    discard: p.discard.map(instance),
    hand: p.hand.map(instance),
    played: p.played.map(instance),
  };
}
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }
function drawOne(actor){
  if(actor.deck.length===0){
    actor.deck.push(...actor.discard);
    actor.discard.length=0; shuffle(actor.deck);
    if(actor===game.player){ addLog('Your deck was shuffled.', 'mint'); Chat.say('shuffle'); }
  }
  if(actor.deck.length>0) actor.hand.push(actor.deck.pop());
  // If player drew while an undo snapshot exists, forbid undo for this step
  if(actor===game.player && game.turn==='player' && game.undo){ game.undoForbidden='draw'; }
}
function drawCards(actor,n){ for(let i=0;i<n;i++) drawOne(actor); }
function vpOfPile(pile){ return pile.reduce((sum,c)=> sum + (c.points||0), 0); }
function computeScores(){ const p = vpOfPile([...game.player.deck,...game.player.discard,...game.player.hand]); const a = vpOfPile([...game.ai.deck,...game.ai.discard,...game.ai.hand]); return {p,a}; }
function cardIcon(name){
  switch(name){
    case 'Copper': return '🟠';
    case 'Silver': return '⚪️';
    case 'Gold': return '🟡';
    case 'Estate': return '🏠';
    case 'Duchy': return '🏯';
    case 'Province': return '🏰';
    case 'Smithy': return '⚒️';
    case 'Village': return '🏘️';
    case 'Market': return '🛒';
    case 'Laboratory': return '🧪';
    case 'Festival': return '🎪';
    case 'Woodcutter': return '🪓';
    case 'Merchant': return '🪙';
    case 'Workshop': return '🧰';
    default: return '🃏';
  }
}

function isChoiceOpen(){ return document.getElementById('choiceOverlay').classList.contains('show'); }
function closeChoiceOverlay(){ const over=document.getElementById('choiceOverlay'); over.classList.remove('show'); game.interactionLock=false; }
function syncLockFromOverlay(){ game.interactionLock = isChoiceOpen(); }

function hasPlayableAction(){ return !game.interactionLock && game.actions>0 && game.player.hand.some(c=>c.type==='Action'); }
function hasTreasure(){ return !game.interactionLock && game.player.hand.some(c=>c.type==='Treasure'); }

function maybeAutoAdvance(){
  if(game.interactionLock) return false; // NEW: never auto-advance while a chooser/lock is open
  if(game.suppressAutoAdvanceOnce){ game.suppressAutoAdvanceOnce=false; return false; }
  if(!game.autoAdvance || game.gameOver) return false;
  let changed=false;
  if(game.phase==='action' && !hasPlayableAction()){ game.phase='treasure'; changed=true; }
  if(game.phase==='treasure' && !hasTreasure()){ game.phase='buy'; changed=true; }
  return changed;
}

function emptyPileCount(){ return SUPPLY.reduce((n,p)=> n + (p.count===0?1:0), 0); }
function getPile(name){ return SUPPLY.find(p=>p.key===name); }
function checkEndgameFlags(){
  const prov = getPile('Province');
  if(prov && prov.count===0) game.endAfterThisTurn = true;
  if(emptyPileCount() >= 3)  game.endAfterThisTurn = true;
  if(game.endAfterThisTurn) addLog('End condition met - game will end after this turn.');
}
function showWinner(){
  const {p,a} = computeScores();
  const title = (p>a)? 'You win!': (a>p? 'AI wins.':'Tie game.');
  document.getElementById('winnerTitle').textContent = title;
  document.getElementById('winnerDetail').textContent = `Final score - You: ${p} · AI: ${a}`;
  document.getElementById('overlay').classList.add('show');
  Chat.endGame(title, {p,a}); // chat stays visible & intact
}

function phaseBand(){
  const prov = getPile('Province');
  const left = prov? prov.count : 12;
  if(left <= 3) return 'late';
  if(left <= 7) return 'mid';
  return 'early';
}

// Player counts HTML builder (frozen per-turn)
function playerCountsHTML(){
  const all=[...game.player.deck, ...game.player.discard, ...game.player.hand];
  const map={}; const typeTotals={Treasure:0, Victory:0, Action:0};
  all.forEach(c=>{ map[c.name]=(map[c.name]||0)+1; typeTotals[c.type]=(typeTotals[c.type]||0)+1; });
  const block=(label,names)=>{
    const total = typeTotals[label]||0;
    const details = names.map(n=> `${n} ${map[n]||0}`).join(' · ');
    return `<div class="countGroup"><div class="row"><span class="label">${label}</span><span class="totalWrap"><span class="mini">total</span><span class="totalNum"><strong>${total}</strong></span></span></div><div class="sub">${details}</div></div>`;
  };
  return [
    block('Treasure',['Gold','Silver','Copper']),
    block('Victory',['Province','Duchy','Estate']),
    block('Action',['Festival','Laboratory','Market','Merchant','Smithy','Village','Workshop','Woodcutter'])
  ].join('');
}

let lastCountsHTML = '';

// ---------- Debug helpers ----------
function groupByName(cards){
  const m = new Map();
  cards.forEach(c=> m.set(c.name, (m.get(c.name)||0)+1));
  return [...m.entries()].sort((a,b)=> a[0].localeCompare(b[0]))
    .map(([n,k])=> `${n}×${k}`).join(', ');
}

function writeAIDebug(lines){
  const box = document.getElementById('ai-debug');
  if(!box) return;
  if(!game.debugAI){ box.style.display='none'; box.textContent=''; return; }
  box.style.display='block';
  box.textContent = (lines||[]).join('\n');
}

// ------------------- Choice overlay (Workshop) -------------------
function openGainChoice(maxCost, actor, source){
  game.interactionLock = true; updateUndoUI();
  const over = document.getElementById('choiceOverlay');
  const grid = document.getElementById('choiceGrid'); grid.innerHTML = '';
  document.getElementById('choiceTitle').textContent = 'Gain a card';
  document.getElementById('choiceDetail').textContent = `Pick a card costing up to ${maxCost}.`;
  const eligible = SUPPLY.filter(p=> p.count>0 && CARD_DEFS[p.key].cost<=maxCost);
  eligible.sort((a,b)=> CARD_DEFS[b.key].cost - CARD_DEFS[a.key].cost || a.key.localeCompare(b.key));
  eligible.forEach(pile=>{
    const def = CARD_DEFS[pile.key];
    const el = document.createElement('div'); el.className='pile';
    el.innerHTML = `<div class="count">${pile.count}</div><div class="name">${cardIcon(def.name)} ${def.name}</div><div class="meta">Cost: ${def.cost}</div>`;
    el.onclick = ()=>{
      pile.count--; actor.discard.push(instance(def.name));
      addLog(`You gained ${def.name} with ${source}.`);
      over.classList.remove('show');
      game.interactionLock = false; updateUndoUI(); checkEndgameFlags(); render();
    };
    el.addEventListener('mouseenter', (e)=> showTip(cardTip(def), e.clientX, e.clientY));
    el.addEventListener('mousemove',  (e)=> showTip(cardTip(def), e.clientX, e.clientY));
    el.addEventListener('mouseleave', hideTip);
    grid.appendChild(el);
  });
  over.classList.add('show');
}

// ------------------- Undo (single-step within player's turn) -------------------
function snapshot(){
  if(game.turn!=='player' || game.gameOver || game.interactionLock) return;
  game.undo = {
    turn: game.turn,
    phase: game.phase,
    actions: game.actions,
    buys: game.buys,
    coins: game.coins,
    endAfter: game.endAfterThisTurn,
    playerPacked: packActor(game.player),
    supply: SUPPLY.map(p=>p.count),
    logs: deepClone(logs),
    merchantPending: deepClone(game.merchantPending),
    turnNum: game.turnNum,
  };
  game.undoForbidden = null; // reset; may become 'draw' if we draw after this
  updateUndoUI();
}
function canUndo(){ return !!game.undo; }
function undo(){
  if(!canUndo()) return;
  if(game.undoForbidden==='draw'){ toast('You cannot use undo after a card draw.'); return; }
  if(isChoiceOpen()) closeChoiceOverlay();
  const u = game.undo;
  game.turn  = u.turn;
  game.phase = u.phase;
  game.actions = u.actions;
  game.buys = u.buys;
  game.coins = u.coins;
  game.endAfterThisTurn = u.endAfter;
  game.player = unpackActor(u.playerPacked);
  SUPPLY.forEach((p,i)=> p.count = u.supply[i]);
  logs.length = 0; u.logs.forEach(x=> logs.push(x));
  game.merchantPending = u.merchantPending;
  game.turnNum = u.turnNum;
  game.undo = null;
  game.interactionLock = false; // hard reset any stale locks
  game.suppressAutoAdvanceOnce = true; // keep restored phase
  updateUndoUI();
  addLog(`Undid last action. Restored phase: ${game.phase}, actions: ${game.actions}, buys: ${game.buys}, coins: ${game.coins}.`, 'mint');
  render();
}
function updateUndoUI(){ const b = document.getElementById('undoBtn'); if(b) b.disabled = !canUndo(); }

// ------------------- Init -------------------
function init(){
  const p=game.player, a=game.ai;
  for(let i=0;i<7;i++){ p.deck.push(instance('Copper')); a.deck.push(instance('Copper')); }
  for(let i=0;i<3;i++){ p.deck.push(instance('Estate')); a.deck.push(instance('Estate')); }
  shuffle(p.deck); shuffle(a.deck);
  for(let i=0;i<5;i++){ drawOne(p); drawOne(a); }
  document.getElementById('autoAdvance').checked=game.autoAdvance;
  document.getElementById('autoAdvance').onchange=(e)=>{ game.autoAdvance=e.target.checked; };
  const sel=document.getElementById('aiMode'); sel.value=game.aiMode; sel.onchange=(e)=>{ game.aiMode=e.target.value; toast(`AI set to ${game.aiMode}`); };
  const dbg=document.getElementById('debugAICheck'); dbg.checked=game.debugAI; dbg.onchange=(e)=>{ game.debugAI=e.target.checked; writeAIDebug([]); };
  lastCountsHTML = playerCountsHTML();
  const pc = document.getElementById('playerCounts'); if(pc) pc.innerHTML = lastCountsHTML;
  addLog(`Build ${BUILD.num} ready. Your turn [${game.turnNum}].`);
  updateUndoUI();
  render();
  Chat.init();
  Chat.startGame();
  Coach.init(); Coach.maybeStart();
  setTimeout(sanityCheck, 0);
}

// ------------------- Rendering -------------------
function render(){
  syncLockFromOverlay();
  document.getElementById('actions').textContent = game.actions;
  document.getElementById('buys').textContent    = game.buys;
  document.getElementById('coins').textContent   = game.coins;
  document.getElementById('phase').textContent   = game.phase.charAt(0).toUpperCase()+game.phase.slice(1);
  const {p,a} = computeScores();
  document.getElementById('pScore').textContent = p;
  document.getElementById('aScore').textContent = a;
  const pc = document.getElementById('playerCounts'); if(pc) pc.innerHTML = lastCountsHTML;

  // SUPPLY
  const s = document.getElementById('supply'); s.innerHTML='';
  const groups = [
    { title:'Coins', type:'Treasure' },
    { title:'Victory Cards', type:'Victory' },
    { title:'Action Cards', type:'Action' },
  ];
  const sortMetric = (def, type)=> type==='Victory' ? (def.points||0) : def.cost;
  groups.forEach(g=>{
    const sec = document.createElement('div'); sec.className='supplySection';
    const h = document.createElement('h3'); h.textContent = g.title; sec.appendChild(h);
    const grid = document.createElement('div'); grid.className='supplyGrid'; sec.appendChild(grid);

    SUPPLY
      .filter(p=>CARD_DEFS[p.key].type===g.type)
      .sort((a,b)=>{
        const da=CARD_DEFS[a.key], db=CARD_DEFS[b.key];
        const va=sortMetric(da,g.type), vb=sortMetric(db,g.type);
        return vb-va || a.key.localeCompare(b.key);
      })
      .forEach(pile=>{
        const def = CARD_DEFS[pile.key];
        const el = document.createElement('div'); el.className='pile';
        if(pile.count===0) el.classList.add('empty');
        el.innerHTML = `
          <div class="count">${pile.count}</div>
          <div class="name"><span class="icon">${cardIcon(def.name)}</span>${def.name}</div>
          <div class="meta">Cost: ${def.cost}</div>
        `;
        const canBuy = (!game.gameOver && !game.interactionLock && game.turn==='player' && game.phase==='buy' && game.buys>0 && game.coins>=def.cost && pile.count>0);
        if(canBuy){ el.onclick = ()=>buy(def.name); el.classList.remove('disabled'); el.classList.add('buyable'); }
        else { el.classList.add('disabled'); el.classList.remove('buyable'); el.onclick = null; }
        el.addEventListener('mouseenter', (e)=> showTip(cardTip(def), e.clientX, e.clientY));
        el.addEventListener('mousemove',  (e)=> showTip(cardTip(def), e.clientX, e.clientY));
        el.addEventListener('mouseleave', hideTip);
        grid.appendChild(el);
      });

    s.appendChild(sec);
  });

  // HAND — sort by type, value/name
  const hand = document.getElementById('player-hand'); hand.innerHTML='';
  const indexed = game.player.hand.map((c,idx)=>({c,idx}));
  const groupRank = { Action:0, Treasure:1, Victory:2 };
  indexed.sort((a,b)=>{
    const ga = groupRank[a.c.type] ?? 3; const gb = groupRank[b.c.type] ?? 3;
    if(ga!==gb) return ga-gb;
    if(a.c.type==='Action' && b.c.type==='Action') return a.c.name.localeCompare(b.c.name);
    if(a.c.type==='Treasure' && b.c.type==='Treasure') return (b.c.value||0)-(a.c.value||0) || a.c.name.localeCompare(b.c.name);
    if(a.c.type==='Victory' && b.c.type==='Victory') return (b.c.points||0)-(a.c.points||0) || a.c.name.localeCompare(b.c.name);
    return a.c.name.localeCompare(b.c.name);
  });
  indexed.forEach(({c,idx})=>{
    const el = document.createElement('div'); el.className='card';
    el.innerHTML = `<div class="title">${cardIcon(c.name)} ${c.name}</div><div class="type">${c.type}</div>`;
    const canPlayAction = (!game.gameOver && !game.interactionLock && c.type==='Action' && game.turn==='player' && game.phase==='action' && game.actions>0);
    const canPlayTreasure = (!game.gameOver && !game.interactionLock && c.type==='Treasure' && game.turn==='player' && game.phase!=='buy');
    if(canPlayAction || canPlayTreasure){ el.classList.add('playable'); el.onclick = ()=>play(idx); }
    else { el.classList.add('disabled'); el.onclick = null; }
    const def = CARD_DEFS[c.name];
    el.addEventListener('mouseenter', (e)=> showTip(cardTip(def), e.clientX, e.clientY));
    el.addEventListener('mousemove',  (e)=> showTip(cardTip(def), e.clientX, e.clientY));
    el.addEventListener('mouseleave', hideTip);
    hand.appendChild(el);
  });

  // Buttons
  document.getElementById('endTurnBtn').onclick = ()=>{ if(!game.interactionLock) endTurn(); };
  document.getElementById('autoTreasureBtn').onclick = ()=>{ if(game.interactionLock) return; if(game.phase==='action') game.phase='treasure'; snapshot(); autoPlayTreasures(); };
  document.getElementById('toBuyBtn').onclick = ()=>{ if(game.interactionLock) return; if(game.phase!=='buy'){ snapshot(); game.phase='buy'; addLog('Buy phase. Buying disables further card play this turn.'); render(); } };
  document.getElementById('undoBtn').onclick = undo;

  const changed = maybeAutoAdvance();
  if(changed) return render();
}

function endIfNeeded(){ if(game.endAfterThisTurn){ game.gameOver=true; showWinner(); return true; } return false; }

// ------------------- Actions & Buys (Player) -------------------
function play(index){
  if(game.interactionLock || game.turn!=='player' || game.gameOver) return;
  const card = game.player.hand[index]; if(!card) return;
  snapshot();
  if(card.type==='Action'){
    if(game.phase!=='action' || game.actions<=0) return;
    game.actions -= 1;
    const [played] = game.player.hand.splice(index,1);
    game.player.played.push(played);
    if(typeof played.effect==='function') played.effect(game, game.player);
    toast(`Played ${played.name}`);
  } else if(card.type==='Treasure'){
    if(game.phase==='buy') return;
    if(game.phase==='action') game.phase='treasure';
    const [tre] = game.player.hand.splice(index,1);
    game.player.played.push(tre);
    let add = (tre.value||0);
    if(tre.name==='Silver' && game.merchantPending.player>0){
      add += game.merchantPending.player; addLog(`Merchant boosts Silver: +${game.merchantPending.player}.`); game.merchantPending.player = 0;
    }
    game.coins += add;
    toast(`+${add} coins`);
  }
  render();
}

function autoPlayTreasures(){
  if(game.turn!=='player' || game.phase==='buy' || game.gameOver) return;
  if(game.phase==='action') game.phase='treasure';
  let added=0; let count=0; let sawSilver=false;
  for(let i=game.player.hand.length-1;i>=0;i--){
    if(game.player.hand[i].type==='Treasure'){
      const card = game.player.hand.splice(i,1)[0];
      game.player.played.push(card); added += (card.value||0); count++;
      if(card.name==='Silver') sawSilver=true;
    }
  }
  if(sawSilver && game.merchantPending.player>0){ added += game.merchantPending.player; addLog(`Merchant boosts Silver: +${game.merchantPending.player}.`); game.merchantPending.player=0; }
  game.coins += added; if(count>0){ addLog(`Auto-played ${count} treasure${count>1?'s':''} for +${added} coins.`); toast(`Auto Treasures: +${added}`); }
  render();
}

function buy(name){
  if(game.interactionLock || game.turn!=='player' || game.phase!=='buy' || game.gameOver) return;
  const pile = getPile(name);
  const def = CARD_DEFS[name];
  if(!pile || !def || pile.count<=0) return;
  if(game.buys<=0){ toast('No buys left'); return; }
  if(game.coins < def.cost){ toast('Not enough coins'); return; }
  snapshot();
  game.buys -= 1; game.coins -= def.cost; pile.count -= 1;
  game.player.discard.push(instance(def.name));
  addLog(`You bought ${def.name} for ${def.cost}.`); toast(`Bought ${def.name} (-${def.cost})`);
  Chat.say('playerBuy', {name:def.name});
  checkEndgameFlags();
  render();
}

// ------------------- Turn Flow -------------------
function cleanupAndDraw(who){
  who.discard.push(...who.hand, ...who.played); who.hand.length=0; who.played.length=0;
  for(let i=0;i<5;i++) drawOne(who);
}

function endTurn(){
  if(game.turn!=='player' || game.gameOver) return;
  game.undo = null; updateUndoUI();
  cleanupAndDraw(game.player);
  lastCountsHTML = playerCountsHTML();
  const pc = document.getElementById('playerCounts'); if(pc) pc.innerHTML = lastCountsHTML;
  if(endIfNeeded()) return;
  game.turn='ai';
  game.actions=1; game.buys=1; game.coins=0; game.phase='action';
  game.merchantPending.ai = 0; // reset per AI turn
  addLog('AI is thinking...'); render();
  setTimeout(aiTurn, 300);
}

// ------------------- AI -------------------
function aiPlayBestActionStrong(debug){
  if(game.aiActions<=0) return false;
  const hand = game.ai.hand;
  const hasTerminal = hand.some(c=> c.name==='Smithy' || c.name==='Woodcutter' || c.name==='Workshop');
  let idx = -1;
  if(hand.some(c=>c.name==='Village') && (game.aiActions<=1) && (hasTerminal)){
    idx = hand.findIndex(c=>c.name==='Village');
  } else if(hand.some(c=>c.name==='Festival')){
    idx = hand.findIndex(c=>c.name==='Festival');
  } else if(hand.some(c=>c.name==='Market')){
    idx = hand.findIndex(c=>c.name==='Market');
  } else if(hand.some(c=>c.name==='Laboratory')){
    idx = hand.findIndex(c=>c.name==='Laboratory');
  } else if(hand.some(c=>c.name==='Merchant')){
    idx = hand.findIndex(c=>c.name==='Merchant');
  } else if(hand.some(c=>c.name==='Smithy')){
    idx = hand.findIndex(c=>c.name==='Smithy');
  } else if(hand.some(c=>c.name==='Workshop')){
    idx = hand.findIndex(c=>c.name==='Workshop');
  } else if(hand.some(c=>c.name==='Village')){
    idx = hand.findIndex(c=>c.name==='Village');
  } else if(hand.some(c=>c.name==='Woodcutter')){
    idx = hand.findIndex(c=>c.name==='Woodcutter');
  }
  if(idx===-1) return false;
  game.aiActions -= 1;
  const [act] = hand.splice(idx,1);
  game.ai.played.push(act);
  if(debug) debug.push(`Action: ${act.name}`);
  if(typeof act.effect==='function') act.effect(game, game.ai);
  return true;
}

function aiPlayBestActionWeak(debug){
  if(game.aiActions<=0) return false;
  const hand = game.ai.hand;
  let order = ['Festival','Market','Laboratory','Merchant','Smithy','Workshop','Village','Woodcutter'];
  let idx = order.map(n=> hand.findIndex(c=>c.name===n)).find(i=>i!==-1) ?? -1;
  if(idx===-1) return false;
  game.aiActions -= 1;
  const [act] = hand.splice(idx,1);
  game.ai.played.push(act);
  if(debug) debug.push(`[Weak] Action: ${act.name}`);
  if(typeof act.effect==='function') act.effect(game, game.ai);
  game.aiActions = 0;
  return true;
}

function aiAutoPlayTreasures(debug){
  let add=0; const played=[]; let sawSilver=false;
  for(let i=game.ai.hand.length-1;i>=0;i--){
    if(game.ai.hand[i].type==='Treasure'){
      const t = game.ai.hand.splice(i,1)[0];
      game.ai.played.push(t); add += (t.value||0); played.push(t);
      if(t.name==='Silver') sawSilver=true;
    }
  }
  if(sawSilver && game.merchantPending.ai>0){ add += game.merchantPending.ai; if(debug) debug.push(`Merchant bonus on Silver: +${game.merchantPending.ai}`); game.merchantPending.ai=0; }
  if(debug && played.length) debug.push(`Treasures: ${groupByName(played)} => +${add}`);
  game.aiCoins += add; return add;
}

function aiCountInDeck(name){
  const all=[...game.ai.deck,...game.ai.discard,...game.ai.hand,...game.ai.played];
  return all.filter(c=>c.name===name).length;
}

function aiGainChoiceUpTo(maxCost){
  const provLeft = getPile('Province')?.count ?? 12;
  if(provLeft<=3){ if(maxCost>=2 && getPile('Estate').count>0) return 'Estate'; }
  const needVillage = aiCountInDeck('Village') < (aiCountInDeck('Smithy') + aiCountInDeck('Workshop'))/2;
  if(needVillage && maxCost>=3 && getPile('Village').count>0) return 'Village';
  if(maxCost>=4 && getPile('Smithy').count>0) return 'Smithy';
  if(maxCost>=3 && getPile('Silver').count>0) return 'Silver';
  if(maxCost>=3 && getPile('Merchant').count>0) return 'Merchant';
  const eligible = SUPPLY.filter(p=> p.count>0 && CARD_DEFS[p.key].cost<=maxCost);
  return eligible.length? eligible[Math.floor(Math.random()*eligible.length)].key : null;
}

function aiChooseBuyStrong(debug){
  const coins = game.aiCoins;
  const phase = phaseBand();
  const piles = { Province:getPile('Province'), Duchy:getPile('Duchy'), Estate:getPile('Estate'), Gold:getPile('Gold'), Silver:getPile('Silver'), Smithy:getPile('Smithy'), Village:getPile('Village'), Market:getPile('Market'), Laboratory:getPile('Laboratory'), Festival:getPile('Festival'), Woodcutter:getPile('Woodcutter'), Merchant:getPile('Merchant'), Workshop:getPile('Workshop') };
  const can = n=> n && n.count>0;
  let pick=null;
  if(coins>=8 && can(piles.Province)) pick='Province';
  else if(coins>=6 && can(piles.Gold)) pick='Gold';
  else if(coins>=5){ const prefs = ['Festival','Market','Laboratory','Smithy']; pick = prefs.find(n=> can(piles[n])) || null; }
  else if(coins>=4 && can(piles.Smithy)) pick='Smithy';
  else if(coins>=3){ const prefs3 = ['Silver','Village','Merchant','Workshop','Woodcutter']; pick = prefs3.find(n=> can(piles[n])) || null; }
  if(phase==='late' && !pick){ if(coins>=5 && can(piles.Duchy)) pick='Duchy'; else if(coins>=2 && can(piles.Estate)) pick='Estate'; }
  if(debug) debug.push(`Buy choice: ${pick??'nothing'} (coins ${coins})`);
  return pick;
}

function aiChooseBuyWeak(debug){
  const coins = game.aiCoins; const provLeft = getPile('Province')?.count ?? 12;
  let pick=null;
  if(coins>=6) pick='Gold';
  else if(coins>=5) pick=['Festival','Market','Laboratory'][Math.floor(Math.random()*3)];
  else if(coins>=4) pick='Smithy';
  else if(coins>=3) pick=['Silver','Merchant','Village','Workshop','Woodcutter'][Math.floor(Math.random()*5)];
  if(!pick && provLeft<=3){ if(coins>=8) pick='Province'; else if(coins>=5) pick='Duchy'; else if(coins>=2) pick='Estate'; }
  if(!pick && coins===0 && Math.random()<0.3 && getPile('Copper').count>0) pick='Copper';
  if(debug) debug.push(`[Weak] Buy choice: ${pick??'nothing'} (coins ${coins})`);
  return pick;
}

function aiMultiBuy(debug, mode){
  let boughtList=[]; let safety=5;
  while(game.aiBuys>0 && safety-->0){
    const choice = (mode==='weak') ? aiChooseBuyWeak(debug) : aiChooseBuyStrong(debug);
    if(!choice) break;
    const pile = getPile(choice); const def = CARD_DEFS[choice];
    if(!pile || pile.count<=0 || game.aiCoins < def.cost) break;
    pile.count--; game.ai.discard.push(instance(choice));
    game.aiCoins -= def.cost; game.aiBuys -= 1; boughtList.push(choice);
    checkEndgameFlags();
  }
  return boughtList;
}

function aiTurn(){
  if(game.gameOver) return;
  const debug = game.debugAI ? [`AI turn start - hand: ${groupByName(game.ai.hand)}`] : null;
  game.aiActions=1; game.aiBuys=1; game.aiCoins=0; game.merchantPending.ai = 0; // reset per AI turn
  const mode = game.aiMode;
  if(mode==='weak'){
    aiPlayBestActionWeak(debug);
  } else {
    let playedSomething=true; let guard=10; while(playedSomething && guard-->0){ playedSomething = aiPlayBestActionStrong(debug); }
  }
  const gained = aiAutoPlayTreasures(debug);
  const boughtList = aiMultiBuy(debug, mode);
  const bought = boughtList.length? boughtList.join(', '): 'nothing';
  document.getElementById('ai-status').textContent = `AI (${mode}) played ${gained} coin${gained===1?'':'s'} and bought ${bought}.`;
  if(game.debugAI){ if(boughtList.length){ debug.push(`Bought: ${boughtList.join(', ')}`); } debug.push(`End coins: ${game.aiCoins}, End buys: ${game.aiBuys}`); writeAIDebug(debug); } else { writeAIDebug([]); }
  cleanupAndDraw(game.ai);
  if(endIfNeeded()) return;
  game.turn='player'; game.merchantPending.player = 0; // reset per player turn
  game.turnNum += 1; // next player turn number
  addLog(`Your turn [${game.turnNum}].`);
  Chat.say('aiTurn', {bought:boughtList, coins:gained});
  render();
}

// ------------------- First-time guide -------------------
const Coach = {
  key:'dominion_guided_v1_done', idx:0, steps:[], el:null, elStep:null, elTitle:null, elText:null,
  init(){
    this.el = document.getElementById('coach');
    this.elStep = document.getElementById('coachStep');
    this.elTitle = document.getElementById('coachTitle');
    this.elText = document.getElementById('coachText');
    document.getElementById('coachNext').onclick = ()=> this.next();
    document.getElementById('coachSkip').onclick = ()=> this.finish(true);
    this.steps = [
      { sel:'#player-hand', title:'Your Hand', text:'Click Actions to play them, or Treasures to generate coins. Tooltips explain cards.', dx:0, dy:-10 },
      { sel:'#supply', title:'Supply', text:'Buy from here in the Buy phase. Piles glow when you can afford them.', dx:0, dy:0 },
      { sel:'.actions', title:'Play Area', text:'Use these buttons: auto-treasure (T), go to Buy (B), Undo (Z), End Turn (E).', dx:0, dy:0 },
      { sel:'#endTurnBtn', title:'End Turn', text:'When you’re done, end your turn and let the AI play.', dx:0, dy:40 },
    ];
  },
  maybeStart(){ try{ if(localStorage.getItem(this.key)) return; this.show(0); }catch(e){} },
  show(i){ this.idx=i; const st=this.steps[i]; if(!st){ return this.finish(); }
    const el = document.querySelector(st.sel); if(!el) return this.finish();
    const r = el.getBoundingClientRect();
    const left = Math.max(12, Math.min(r.left + (st.dx||0), window.innerWidth-300));
    const top  = Math.max(12, Math.min(r.top - 8 + (st.dy||0), window.innerHeight-140));
    this.elTitle.textContent = st.title; this.elText.textContent = st.text;
    this.el.classList.add('show');
    this.elStep.style.left = left + 'px'; this.elStep.style.top = top + 'px';
  },
  next(){ const ni=this.idx+1; if(ni>=this.steps.length) return this.finish(); this.show(ni); },
  finish(skipped){ this.el.classList.remove('show'); try{ localStorage.setItem(this.key, '1'); }catch(e){} }
};

// ------------------- Sanity / smoke checks -------------------
function sanityCheck(){
  try{
    LOG_SILENT = true; // silence any test logs
    const supplyPiles = document.querySelectorAll('#supply .pile').length;
    const okSupply = supplyPiles >= 14 && SUPPLY.some(p=>p.key==='Market') && SUPPLY.some(p=>p.key==='Merchant') && SUPPLY.some(p=>p.key==='Workshop');
    const okHand = Array.isArray(game.player.hand) && game.player.hand.length === 5;
    const okFns = typeof CARD_DEFS?.Smithy?.effect === 'function' && typeof cardIcon === 'function';
    const okChatRaised = getComputedStyle(document.getElementById('chatPanel')).bottom === '88px';
    const dummy = { actions:0, buys:0, coins:0, player:{deck:[],discard:[],hand:[],played:[]}, ai:{}, aiActions:0, aiBuys:0, aiCoins:0, merchantPending:{player:0,ai:0} };
    CARD_DEFS.Woodcutter.effect(dummy, dummy.player); const okPlusBuy = dummy.buys===1 && dummy.coins===2;
    CARD_DEFS.Laboratory.effect(dummy, dummy.player); const okLabAction = dummy.actions===1;
    CARD_DEFS.Merchant.effect(dummy, dummy.player); const okMerchantFlag = dummy.merchantPending.player===1;
    // quick undo smoke without logging
    const pre = deepClone({ phase:game.phase, actions:game.actions });
    snapshot(); game.interactionLock=true; game.interactionLock=false; const hasUndo = !!game.undo; game.undo = null; updateUndoUI();
    const afterOK = (game.phase===pre.phase && game.actions===pre.actions);
    LOG_SILENT = false;

    if(!(okSupply && okHand && okFns && okPlusBuy && okLabAction && okMerchantFlag && okChatRaised && hasUndo && afterOK)){
      const msg = `Sanity failed (supply:${okSupply}, hand5:${okHand}, fns:${okFns}, +Buy:${okPlusBuy}, lab+Action:${okLabAction}, merchantFlag:${okMerchantFlag}, chatRaised:${okChatRaised}, undo:${hasUndo&&afterOK}).`;
      console.error(msg); toast(msg);
    } else { console.log('Sanity check passed.'); }
  }catch(e){ LOG_SILENT=false; console.error('Sanity check exception', e); toast('Sanity check exception'); }
}

// ------------------- Keyboard Shortcuts -------------------
function firstPlayableActionIndex(){
  if(game.turn!=='player' || game.phase!=='action' || game.actions<=0 || game.interactionLock) return -1;
  return game.player.hand.findIndex(c=>c.type==='Action');
}

document.addEventListener('keydown', (ev)=>{
  const k = ev.key.toLowerCase();
  if(k==='a'){
    const idx = firstPlayableActionIndex(); if(idx>=0){ play(idx); ev.preventDefault(); }
  } else if(k==='t'){
    if(game.interactionLock) return; if(game.phase==='action') game.phase='treasure'; snapshot(); autoPlayTreasures(); ev.preventDefault();
  } else if(k==='b'){
    if(game.interactionLock) return; if(game.phase!=='buy'){ snapshot(); game.phase='buy'; addLog('Buy phase. Buying disables further card play this turn.'); render(); } ev.preventDefault();
  } else if(k==='e'){
    if(game.interactionLock) return; endTurn(); ev.preventDefault();
  } else if(k==='z'){
    undo(); ev.preventDefault();
  }
});

// ------------------- Chat Bot (persisted) -------------------
const Chat = {
  elPanel:null, elBody:null, elInput:null, said:new Set(), storageKey:'dominion_chat_v1',
  init(){
    this.elPanel = document.getElementById('chatPanel');
    this.elBody  = document.getElementById('chatBody');
    this.elInput = document.getElementById('chatInput');
    document.getElementById('chatSend').onclick = ()=> this.send();
    document.getElementById('clearChat').onclick = ()=> this.clear();
    this.elInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); this.send(); } });
    this.load();
  },
  scroll(){ this.elBody.scrollTop = this.elBody.scrollHeight; },
  variant(text){ const suf = [' •',' …',' 🙂',' 🤖',' ✨',' !',' ~'][Math.floor(Math.random()*7)]; let v = text + suf; while(this.said.has(v)) v = text + suf + Math.floor(Math.random()*9); return v; },
  post(role, text){ if(role==='bot'){ if(this.said.has(text)) text = this.variant(text); this.said.add(text); } const line = document.createElement('div'); line.className = 'msg ' + (role==='bot'?'bot':'user'); const bubble = document.createElement('div'); bubble.className='bubble'; bubble.textContent=text; line.appendChild(bubble); this.elBody.appendChild(line); this.persist(); this.scroll(); },
  postUnique(lines){ const pool = lines.filter(t=> !this.said.has(t)); const pick = (arr)=> arr[Math.floor(Math.random()*arr.length)]; const chosen = (pool.length? pick(pool) : this.variant(pick(lines))); this.post('bot', chosen); },
  persist(){ const items = [...this.elBody.querySelectorAll('.msg')].slice(-150).map(n=>({ role: n.classList.contains('bot')? 'bot':'user', text: n.querySelector('.bubble')?.textContent || '' })); try{ localStorage.setItem(this.storageKey, JSON.stringify({items, said:[...this.said].slice(-500)})); }catch(e){} },
  load(){ try{ const raw = localStorage.getItem(this.storageKey); if(!raw) return; const data = JSON.parse(raw); this.said = new Set(Array.isArray(data?.said)? data.said: []); (data?.items||[]).forEach(it=> this.post(it.role, it.text)); }catch(e){} },
  clear(){ this.elBody.innerHTML=''; this.said.clear(); this.persist(); },
  send(){ const v = this.elInput.value.trim(); if(!v) return; this.post('user', v); this.elInput.value=''; setTimeout(()=> this.reply(v), 120); },
  reply(text){ const t = text.toLowerCase(); if(t.includes('help')||t.includes('how')) return this.post('bot', 'Phases go Action → Treasure → Buy. Hit T to auto-play treasures, B to buy, Z to undo.'); if(t.includes('why') && t.includes('buy')) return this.post('bot', 'Simple plan: build economy (Silver/Gold), add Market/Festival, sprinkle Merchants, green when Provinces drop.'); if(t.includes('score')){ const {p,a}=computeScores(); return this.post('bot', `VP check → You: ${p}, AI: ${a}.`); } this.postUnique(['Auto-Treasure (T) saves clicks; Undo (Z) saves regrets.','Greening too early can stall—watch Province pile count.','Merchants love Silvers; try to play at least one.','Workshop can fix economy: gain Silver or a key 4-cost like Smithy.']); },
  say(evt, data){ if(evt==='shuffle'){ return this.postUnique(['Shuffle time! Minty fresh deck.','Cards doing cardio: shuffle complete.','Shuffled—your Estates promised to behave.','Riffle, riffle. Deal me a win.','New order, who dis?',]); } if(evt==='playerBuy'){ const mapping = { Province:'Province! Bold move. I can smell the victory points.', Market:'Bought a Market. Economy go brrr.', Festival:'Festival acquired. Confetti not included.', Laboratory:'Lab online. Please wear safety goggles while drawing cards.', Woodcutter:'Woodcutter hired. Lumber? I hardly know her.', Merchant:'Merchant secured. May your Silvers be lucrative.', Workshop:'Workshop online. Time to craft value.', }; return this.post('bot', mapping[data?.name] || `Picked up ${data?.name}. Nice.`); } if(evt==='aiTurn'){ const bought = (data?.bought||[]).join(', ') || 'nothing'; const lines=[`AI bought ${bought}. We can beat that.`,`AI turn over. My analysis: 🤖 mid.`, bought.includes('Province')? 'AI went green. Time to race!':'AI didn\'t touch Provinces. Opportunity knocks.', 'If AI buys nothing, we buy something shiny.','AI thinks long term. We think victory screen.',]; return this.postUnique(lines); } }
};

// ------------------- Start -------------------
init();
</script>
</body>
</html>
